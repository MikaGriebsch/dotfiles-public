#!/usr/bin/env bash

# Reads recently opened files from Neovim ShaDa (v:oldfiles) instead of Vim's ~/.viminfo
# Copyright (c) 2011 rupa deadwyler. Licensed under the WTFPL license, Version 2

vim=nvim

usage="$(basename $0) [-a] [-c] [-l] [-[0-9]] [--debug] [--help] [regexes]"

[ $1 ] || list=1

_pwd="$(command pwd)"

fnd=()
for x; do
  case $x in
  -a) deleted=1 ;;
  -c)
    subdir=1
    shift
    ;;
  -l) list=1 ;;
  -[0-9])
    edit=${x:1}
    shift
    ;;
  --help)
    echo $usage
    exit
    ;;
  --debug) vim=echo ;;
  --)
    shift
    fnd+=("$@")
    break
    ;;
  *) fnd+=("$x") ;;
  esac
  shift
done
set -- "${fnd[@]}"

[ -f "$1" ] && {
  $vim "$1"
  exit
}


# Fetch old files from Neovim's ShaDa (v:oldfiles)
# Using headless nvim, explicitly reading ShaDa to ensure it's loaded
oldfiles_output=$(nvim --headless +rshada +'lua for _, f in ipairs(vim.v.oldfiles) do io.stdout:write(f .. "\n") end' +qa 2>/dev/null)

i=0
while IFS= read -r fl; do
  [ -n "$fl" ] || continue
  _fl="${fl/~\//$HOME/}"
  [ -f "$_fl" -o "$deleted" ] || continue
  match=1
  for x; do
    [[ "$fl" =~ $x ]] || match=
  done
  if [ "$subdir" ]; then
    case "$_fl" in
      $_pwd*) ;;
      *) match= ;;
    esac
  fi
  [ "$match" ] || continue
  i=$((i + 1))
  files[$i]="$fl"
done <<< "$oldfiles_output"

if [ "$edit" ]; then
  resp=${files[$((edit + 1))]}
elif [ "$i" = 1 -o "$list" = "" ]; then
  resp=${files[1]}
elif [ "$i" ]; then
  while [ $i -gt 0 ]; do
    echo -e "$((i - 1))\t${files[$i]}"
    i=$((i - 1))
  done
  read -p '> ' CHOICE
  [ "$CHOICE" ] && resp=${files[$((CHOICE + 1))]}
fi

[ "$resp" ] || exit
$vim "${resp/\~/$HOME}"
